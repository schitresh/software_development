## User Management
- It is advisable to use common plugins for authorization and authentication
  - Rather than rolling your own (e.g. device, authlogic)
- Good ones store only cryptographically hashed passwords, not in plain-text
- Rails has built-in method has_secure_password
  - Supports secure password hashing, confirmation, & recovery mechanisms

## Brute Forcing Accounts
- A list of usernames of webapp may be misused to brute force corresponding passwords
  - Because most people don't use sophisticated passwords
  - Most passwords are a combination of dictionary words and possibly numbers
- Because of this, most web applications will display a generic error message
  - Like username or password is incorrect
  - But in forgot password pages, most admit that username not found
  - This allows an attacker to compile a list of usernames and brute-force the accounts
- Require to enter a CAPTCHA after a number of failed logins from a certain IP address
  - However, it's not bullet proof since these automated programs may change their IP
  - But it raises an barrier to attack

## Account Hijacking
- Passwords
  - If an attacker steals a user's session cookie and co-uses the application
    - It is easy to change the password and hijack the account
    - Require the user to enter the old password when changing
  - If the change password form is vulnerable to CSRF
    - An attacker might change password by luring users to a web page
    - And presenting a crafted img-tag which does CSRF
    - So make this form safe against CSRF
- Email
  - Attacker may also take over the account by changing email address
  - After that, they will change the password using the forgot password page
  - Require the user to enter password when changing the email address too
- CSRF & XSS vulnerability in mail client
  - Victim is lured to a website controlled by the attacker
  - Where a crafter img-tag is present and results in a http get request
    - That changes the filter settings of the mail client
    - To forward all emails to their email address

## CAPTCHA
- CAPTCHA is a challenge-response test
  - To determine that the response is not generated by a computer
  - Used to protect registration forms from attackers
  - And comment forms from automatic spam bots
- Positive captcha
  - Asking users to type the letters of a distorted image
  - A popular positive captcha api is recaptcha
    - You will get two keys from the api (public & private) to put in rails env
    - After that, you can use recaptcha_tags in view and verify_repatcha in controller
- Negative captcha
  - Most bots are really naive
  - They crawl the web and put their spam into every form's field they can find
  - Negative captchas take advantage of that and include a honeypot field
  - This field is hidden from human users by css or javascript
  - Though they won't suffice to protect against targeted tailor-made bots

## Logging
- By default, rails logs all requests being made to the webapp
  - What will happen if an attacker got full access to the web server
  - Encrypting secrets & passwords in the database will be quite useless
- Filter certain request parameters from the log files
  - Like login credentials, credit card numbers, etc.
  - `config.filter_parameters << :password`
  - Default filters initialized in 'initializers/filter_parameter_logging.rb'
    - :passw, :secret, token to handle password, password confirmation, my_token

## Regular Expressions
- Ruby uses a slightly different approach to match beginning & end of a string
- In ruby, '^' & '$' match the line beginning & end
- So regex like /^https?:\/\/[^\n]+$/i matches the second line & rest doesn't matter
  - javascript:exploit_code():/*
  - http://hi.com
  - */
- '\A' & \z' should be used instead of '^' & '$'
  - /\Ahttps?:\/\/[^\n]+\z/i

## Privilege Escalation
- The most common parameter that a user might tamper with is the id parameter
  - Like http://www.domain.com/project/1 has id 1
- It will be available in params in the controller
  - `@project = Project.find(params[:id])`
- If the user changes the id to 42 and if it is not to be allowed
  - They will have access to it anyway
- So query the user's access rights
  - `@project = @current_user.projects.find(params[:id])`

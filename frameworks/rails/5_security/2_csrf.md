## Cross-Site Request Forgery (CSRF)
- Malicious code or link is included that accesses a web application
  - The user is believed to have authenticated that webapp
  - If the session has not timed out, attacker may execute unauthorized commands
- Webapps use cookie-based sessions
  - Either they store the session ID in the cookie & have a server-side session hash
  - Or the entire session hash is on the client side
  - In either case the browser automatically sends the cookie on very request
  - If the request comes from a site of a different domain, it will also send the cookie
    - For example, embedded in facebook post

## Example
- Bob browses a message board and views a post from a hacker
- It contains a crafted HTML image element
  - That references a command in Bob's project management app
  - Rather than an image file: <img src="http://www.webapp.com/project/1/destroy">
- Bob's session at www.webapp.com is still alive because he didn't log out
- By viewing the post, the browser finds an image tag
  - And tries to load the suspected image from www.webapp.com
  - It will aslo send along the cookie with the session ID
- The webapp verifies the user info in the corresponding session hash
  - And destroys the project with the ID 1
  - And returns a result page which is unexpected result for the browser
  - So it will not display the image
- Bob does't notice the attack but a few days later he finds out
  - That the project number one is gone

## Use Get and Post appropriately
- Use get if the interaction is more like a question
  - That is, if it is a safe operation like query, read operation, lookup
- Use post if the interaction is more like an order
  - Or changes the state or the resource (e.g. subscription to a service)
  - Or the user is held accountable for the results of the interaction
- Post requests can be sent automatically also using onclick or mouseover events
  - Or using javascript code inside a response
  - We must disallow cross-site <script> tags
  - Ajax requests obey the same-origin policy, so that can be allowed to return JS

```html
<a
  href="http://www.harmless.com/"
  onclick="
    var f = document.createElement('form');
    f.style.display = 'none';
    this.parentNode.appendChild(f);
    f.method = 'POST';
    f.action = 'http://www.example.com/account/destroy';
    f.submit();
    return false;
  "
>
  To the harmless survey
</a>

<img
  src="http://www.harmless.com/img" width="400" height="400"
  onmouseover="..."
/>
```

## Required Security Token
- To protect against all other forged requests
  - Rails includes a security token in requests and verifies it on the server
- The config 'default_protect_from_forgery' is true by default
  - This will include security token in all forms generated by rails
- It can be done manually by adding 'protect_from_forgery with: :exception'
  - In application controller to throw exception if token doesn't match
- For turbo, <%= csrf_meta_tags %> tag is included in head of application layout
  - It adds to the request in the 'X-CSRF-Token' request header
- While using another library to make Ajax calls
  - It is necessary to add security token as a default header yourself

## Clearing Persistent Cookies
- It is common to use persistent cookies to store user info
- In this case, cookies won't be cleared
  - And the out of the box CSRF protection won't be effective
  - Add a manual method that runs if CSRF token is absent or incorrect on non-Get request
- Cross site scripting (XSS) bypass all CSRF protections
  - It gives attacker access to all elements on a page
  - So they can read the CSRF security token fron a form or directly submit form
